/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package Lukavron.language.Lukavron;

import java.util.Map;
import java.util.TreeMap;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

import mettel.core.tableau.MettelSubstitution;
public class LukavronTreeSubstitution implements LukavronSubstitution{

    protected final Map<Lukavron_valuationVariable, Lukavron_valuation> valuationMap = new TreeMap<Lukavron_valuationVariable, Lukavron_valuation>();
    public Lukavron_valuation get_valuation(Lukavron_valuationVariable v){
        return valuationMap.get(v);
    }

    public Map<Lukavron_valuationVariable, Lukavron_valuation> valuationMap(){
        return valuationMap;
    }

    public boolean append(Lukavron_valuationVariable v, Lukavron_valuation e1){
        if(v == null || e1 == null){ return false; }
        final Lukavron_valuation e = valuationMap.get(v);
        if(e == null){
            valuationMap.put(v,e1);
            return true;
        }else{
            return (e.equals(e1));
        }
    }

    protected final Map<Lukavron_formulaVariable, Lukavron_formula> formulaMap = new TreeMap<Lukavron_formulaVariable, Lukavron_formula>();
    public Lukavron_formula get_formula(Lukavron_formulaVariable v){
        return formulaMap.get(v);
    }

    public Map<Lukavron_formulaVariable, Lukavron_formula> formulaMap(){
        return formulaMap;
    }

    public boolean append(Lukavron_formulaVariable v, Lukavron_formula e1){
        if(v == null || e1 == null){ return false; }
        final Lukavron_formula e = formulaMap.get(v);
        if(e == null){
            formulaMap.put(v,e1);
            return true;
        }else{
            return (e.equals(e1));
        }
    }

    public boolean append(LukavronSubstitution s){
        final Map<Lukavron_valuationVariable, Lukavron_valuation> m_valuation = s.valuationMap();
        for(Lukavron_valuationVariable key:m_valuation.keySet()){
            if(!append(key,s.get_valuation(key))){ return false; }
        }
        final Map<Lukavron_formulaVariable, Lukavron_formula> m_formula = s.formulaMap();
        for(Lukavron_formulaVariable key:m_formula.keySet()){
            if(!append(key,s.get_formula(key))){ return false; }
        }
        return true;
    }

    public MettelSubstitution merge(MettelSubstitution s){
        LukavronTreeSubstitution result = new LukavronTreeSubstitution();
        result.append(this);
        if(result.append((LukavronTreeSubstitution)s)){
            return result;
        }else{
            return null;
        }
    }

    private static LukavronTreeSubstitution appendArray(LukavronTreeSubstitution s, MettelSubstitution[] array){
        if(array == null) return null;
        final int SIZE = array.length;
        if(SIZE == 0) return null;
        for(int i = 0; i < SIZE; i++){
            Set<Entry<Lukavron_valuationVariable, Lukavron_valuation>> entry_valuationSet = ((LukavronSubstitution)array[i]).valuationMap().entrySet();
            for(Entry<Lukavron_valuationVariable, Lukavron_valuation> entry:entry_valuationSet){
                if(!s.append(entry.getKey(),entry.getValue())) return null;
            }
            Set<Entry<Lukavron_formulaVariable, Lukavron_formula>> entry_formulaSet = ((LukavronSubstitution)array[i]).formulaMap().entrySet();
            for(Entry<Lukavron_formulaVariable, Lukavron_formula> entry:entry_formulaSet){
                if(!s.append(entry.getKey(),entry.getValue())) return null;
            }
        }
        return s;
    }

    public MettelSubstitution mergeArray(MettelSubstitution[] array){
        return appendArray(new LukavronTreeSubstitution(),array);
    }

    public MettelSubstitution merge(MettelSubstitution[] array){
        LukavronTreeSubstitution s = new LukavronTreeSubstitution();
        s.valuationMap().putAll(valuationMap);
        s.formulaMap().putAll(formulaMap);
        return appendArray(s,array);
    }

    public int compareTo(MettelSubstitution s){
        if(s == this){ return 0; }
        final Set<Lukavron_valuationVariable> keys_valuation0 = valuationMap.keySet();
        final Set<Lukavron_valuationVariable> keys_valuation1 = ((LukavronSubstitution)s).valuationMap().keySet();
        final TreeSet<Lukavron_valuationVariable> keys_valuation = new TreeSet<Lukavron_valuationVariable>(keys_valuation0);
        keys_valuation.addAll(keys_valuation1);
        for(Lukavron_valuationVariable key:keys_valuation){
            if(!keys_valuation0.contains(key)){
                return 1;
            }else{
                if(!keys_valuation1.contains(key)){
                    return -1;
                }else{
                    final Lukavron_valuation v0 = valuationMap.get(key);
                    final Lukavron_valuation v1 = ((LukavronSubstitution)s).get_valuation(key);
                    final int result = v0.compareTo(v1);
                    if(result != 0){ return result; }
                }
            }
        }
        final Set<Lukavron_formulaVariable> keys_formula0 = formulaMap.keySet();
        final Set<Lukavron_formulaVariable> keys_formula1 = ((LukavronSubstitution)s).formulaMap().keySet();
        final TreeSet<Lukavron_formulaVariable> keys_formula = new TreeSet<Lukavron_formulaVariable>(keys_formula0);
        keys_formula.addAll(keys_formula1);
        for(Lukavron_formulaVariable key:keys_formula){
            if(!keys_formula0.contains(key)){
                return 1;
            }else{
                if(!keys_formula1.contains(key)){
                    return -1;
                }else{
                    final Lukavron_formula v0 = formulaMap.get(key);
                    final Lukavron_formula v1 = ((LukavronSubstitution)s).get_formula(key);
                    final int result = v0.compareTo(v1);
                    if(result != 0){ return result; }
                }
            }
        }
        return 0;
    }

    private int hashCode = 0;
    public int hashCode(){
        hashCode = 1;
        hashCode = 31*hashCode + valuationMap.hashCode();
        hashCode = 31*hashCode + formulaMap.hashCode();
        return hashCode;
    }

    public boolean equals(Object o){
        if(o == this){ return true; }
        if(!(o instanceof LukavronSubstitution)){ return false; }
        final LukavronSubstitution s = (LukavronSubstitution)o;
        return valuationMap.equals(s.valuationMap()) && formulaMap.equals(s.formulaMap());
    }

    public String toString(){
        StringBuilder b = new StringBuilder();
        b.append("$[");
        boolean notFirst = false;
        Set<Entry<Lukavron_valuationVariable, Lukavron_valuation>> valuationEntrySet = valuationMap.entrySet();
        for(Entry<Lukavron_valuationVariable, Lukavron_valuation> entry:valuationEntrySet){
            if(notFirst){
                b.append(", ");
            }else{
                notFirst = true;
            }
            b.append(entry.getKey());
            b.append('/');
            b.append(entry.getValue());
        }
        Set<Entry<Lukavron_formulaVariable, Lukavron_formula>> formulaEntrySet = formulaMap.entrySet();
        for(Entry<Lukavron_formulaVariable, Lukavron_formula> entry:formulaEntrySet){
            if(notFirst){
                b.append(", ");
            }else{
                notFirst = true;
            }
            b.append(entry.getKey());
            b.append('/');
            b.append(entry.getValue());
        }
        b.append(']');
        return b.toString();
    }

}
