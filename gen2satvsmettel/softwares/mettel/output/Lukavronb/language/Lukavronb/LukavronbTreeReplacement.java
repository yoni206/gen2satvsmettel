/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package Lukavronb.language.Lukavronb;

import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.TreeSet;
import java.util.Map.Entry;
import mettel.core.tableau.MettelReplacement;
import mettel.core.tableau.MettelSubstitution;
import mettel.core.tableau.MettelExpression;

public class LukavronbTreeReplacement implements LukavronbReplacement{

    private class Pointer<T extends LukavronbExpression>{
        T expression = null;
        Pointer(T expression){
            super();
            this.expression = expression;
        }
        public int hashCode(){
            return expression.hashCode();
        }
    }

    private Comparator<LukavronbAbstractExpression> comparator = new LukavronbIDComparator();

    protected final Map<Lukavronb_valuation, Pointer<Lukavronb_valuation>> valuationMap = new TreeMap<Lukavronb_valuation, Pointer<Lukavronb_valuation>>();
    public Lukavronb_valuation get_valuation(Lukavronb_valuation e){
        final Pointer<Lukavronb_valuation> p = valuationMap.get(e);
        return p == null? null: p.expression;
    }

    public Set<Lukavronb_valuation> valuationKeys(){
        return valuationMap.keySet();
    }

    public boolean append(Lukavronb_valuation e0, Lukavronb_valuation e1){
        if(e0 == null || e1 == null){ return false; }
        final int CMP = comparator.compare((LukavronbAbstractExpression)e0,(LukavronbAbstractExpression)e1);
        if(CMP == 0) return false;
            Lukavronb_valuation left = null;
            Lukavronb_valuation right = null;
            if(CMP > 0){
                left = e0;
                right = e1;
            }else{
                left = e1;
                right = e0;
            }
            final Pointer<Lukavronb_valuation> entry = valuationMap.get(left);
            if(entry == null){
                final Pointer<Lukavronb_valuation> rEntry = valuationMap.get(right);
                if(rEntry == null) {
                    valuationMap.put(left, new Pointer<Lukavronb_valuation>(right));
                }else{
                    valuationMap.put(left, rEntry);
                }
                return true;
            }else{
                final Lukavronb_valuation third = entry.expression;
                final int CMP0 = comparator.compare((LukavronbAbstractExpression)right, (LukavronbAbstractExpression)third);
                if(CMP0 == 0) return false;
                if(CMP0 > 0){
                    valuationMap.put(right, entry);
                    return true;
                }else{
                    entry.expression = right;
                    valuationMap.put(third, entry);
                    return true;
                }
            }
        }

        protected final Map<Lukavronb_formula, Pointer<Lukavronb_formula>> formulaMap = new TreeMap<Lukavronb_formula, Pointer<Lukavronb_formula>>();
        public Lukavronb_formula get_formula(Lukavronb_formula e){
            final Pointer<Lukavronb_formula> p = formulaMap.get(e);
            return p == null? null: p.expression;
        }

        public Set<Lukavronb_formula> formulaKeys(){
            return formulaMap.keySet();
        }

        public boolean append(Lukavronb_formula e0, Lukavronb_formula e1){
            if(e0 == null || e1 == null){ return false; }
            final int CMP = comparator.compare((LukavronbAbstractExpression)e0,(LukavronbAbstractExpression)e1);
            if(CMP == 0) return false;
                Lukavronb_formula left = null;
                Lukavronb_formula right = null;
                if(CMP > 0){
                    left = e0;
                    right = e1;
                }else{
                    left = e1;
                    right = e0;
                }
                final Pointer<Lukavronb_formula> entry = formulaMap.get(left);
                if(entry == null){
                    final Pointer<Lukavronb_formula> rEntry = formulaMap.get(right);
                    if(rEntry == null) {
                        formulaMap.put(left, new Pointer<Lukavronb_formula>(right));
                    }else{
                        formulaMap.put(left, rEntry);
                    }
                    return true;
                }else{
                    final Lukavronb_formula third = entry.expression;
                    final int CMP0 = comparator.compare((LukavronbAbstractExpression)right, (LukavronbAbstractExpression)third);
                    if(CMP0 == 0) return false;
                    if(CMP0 > 0){
                        formulaMap.put(right, entry);
                        return true;
                    }else{
                        entry.expression = right;
                        formulaMap.put(third, entry);
                        return true;
                    }
                }
            }

            public boolean isEmpty(){
                return valuationMap.isEmpty() && formulaMap.isEmpty();
            }

            public boolean append(MettelExpression e0, MettelExpression e1){
                if(e0 instanceof Lukavronb_valuation){ return append((Lukavronb_valuation)e0, (Lukavronb_valuation)e1); }
                if(e0 instanceof Lukavronb_formula){ return append((Lukavronb_formula)e0, (Lukavronb_formula)e1); }
                return false;
            }

            public boolean append(MettelReplacement r){
                if(r == null){ return false; }
                return append((LukavronbReplacement)r);
            }

            public MettelExpression rewrite(MettelExpression e) {
                if(e instanceof Lukavronb_valuation){
                    return ((Lukavronb_valuation)e).rewrite(this);
                }
                if(e instanceof Lukavronb_formula){
                    return ((Lukavronb_formula)e).rewrite(this);
                }
                return null;
            }

            public MettelSubstitution rewrite(MettelSubstitution s) {
                final LukavronbSubstitution s0 = (LukavronbSubstitution)s;
                LukavronbSubstitution res = new LukavronbTreeSubstitution();
                final Set<Entry<Lukavronb_valuationVariable, Lukavronb_valuation>> valuationEntrySet = s0.valuationMap().entrySet();
                for(Entry<Lukavronb_valuationVariable, Lukavronb_valuation> entry:valuationEntrySet){
                    res.append(entry.getKey(),(Lukavronb_valuation)rewrite(entry.getValue()));
                }
                final Set<Entry<Lukavronb_formulaVariable, Lukavronb_formula>> formulaEntrySet = s0.formulaMap().entrySet();
                for(Entry<Lukavronb_formulaVariable, Lukavronb_formula> entry:formulaEntrySet){
                    res.append(entry.getKey(),(Lukavronb_formula)rewrite(entry.getValue()));
                }
                return res;
            }

            public boolean append(LukavronbReplacement r){
                boolean result = false;
                final Set<Lukavronb_valuation> valuationKeys = r.valuationKeys();
                for(Lukavronb_valuation key:valuationKeys){
                    result |= append(key, r.get_valuation(key));
                }
                final Set<Lukavronb_formula> formulaKeys = r.formulaKeys();
                for(Lukavronb_formula key:formulaKeys){
                    result |= append(key, r.get_formula(key));
                }
                return result;
            }

            private int hashCode = 0;
            public int hashCode(){
                hashCode = 1;
                hashCode = 31*hashCode + valuationMap.hashCode();
                hashCode = 31*hashCode + formulaMap.hashCode();
                return hashCode;
            }

            public int compareTo(MettelReplacement r){
                if(r == this){ return 0; }
                final Set<Lukavronb_valuation> keys_valuation0 = valuationMap.keySet();
                final Set<Lukavronb_valuation> keys_valuation1 = ((LukavronbReplacement)r).valuationKeys();
                final TreeSet<Lukavronb_valuation> keys_valuation = new TreeSet<Lukavronb_valuation>(keys_valuation0);
                keys_valuation.addAll(keys_valuation1);
                for(Lukavronb_valuation key:keys_valuation){
                    if(!keys_valuation0.contains(key)){
                        return 1;
                    }else{
                        if(!keys_valuation1.contains(key)){
                            return -1;
                        }else{
                            final Lukavronb_valuation v0 = valuationMap.get(key).expression;
                            final Lukavronb_valuation v1 = ((LukavronbReplacement)r).get_valuation(key);
                            final int result = v0.compareTo(v1);
                            if(result != 0){ return result; }
                        }
                    }
                }
                final Set<Lukavronb_formula> keys_formula0 = formulaMap.keySet();
                final Set<Lukavronb_formula> keys_formula1 = ((LukavronbReplacement)r).formulaKeys();
                final TreeSet<Lukavronb_formula> keys_formula = new TreeSet<Lukavronb_formula>(keys_formula0);
                keys_formula.addAll(keys_formula1);
                for(Lukavronb_formula key:keys_formula){
                    if(!keys_formula0.contains(key)){
                        return 1;
                    }else{
                        if(!keys_formula1.contains(key)){
                            return -1;
                        }else{
                            final Lukavronb_formula v0 = formulaMap.get(key).expression;
                            final Lukavronb_formula v1 = ((LukavronbReplacement)r).get_formula(key);
                            final int result = v0.compareTo(v1);
                            if(result != 0){ return result; }
                        }
                    }
                }
                return 0;
            }

            public boolean equals(Object o){
                if(o == this){ return true; }
                if(!(o instanceof LukavronbReplacement)){ return false; }
                final LukavronbReplacement r = (LukavronbReplacement)o;
                final Set<Lukavronb_valuation> valuationKeys = valuationMap.keySet();
                if(!valuationKeys.equals(r.valuationKeys())) return false;
                for(Lukavronb_valuation key:valuationKeys){
                    final Lukavronb_valuation v = valuationMap.get(key).expression;
                    if(!v.equals(r.get_valuation(key))) return false;
                }
                final Set<Lukavronb_formula> formulaKeys = formulaMap.keySet();
                if(!formulaKeys.equals(r.formulaKeys())) return false;
                for(Lukavronb_formula key:formulaKeys){
                    final Lukavronb_formula v = formulaMap.get(key).expression;
                    if(!v.equals(r.get_formula(key))) return false;
                }
                return true;
            }

            public String toString(){
                StringBuilder b = new StringBuilder();
                b.append("$[");
                boolean notFirst = false;
                final Set<Entry<Lukavronb_valuation, Pointer<Lukavronb_valuation>>> valuationEntrySet = valuationMap.entrySet();
                for(Entry<Lukavronb_valuation, Pointer<Lukavronb_valuation>> entry:valuationEntrySet){
                    if(notFirst){
                        b.append(", ");
                    }else{
                        notFirst = true;
                    }
                    b.append(entry.getKey());
                    b.append('/');
                    b.append(entry.getValue().expression);
                }
                final Set<Entry<Lukavronb_formula, Pointer<Lukavronb_formula>>> formulaEntrySet = formulaMap.entrySet();
                for(Entry<Lukavronb_formula, Pointer<Lukavronb_formula>> entry:formulaEntrySet){
                    if(notFirst){
                        b.append(", ");
                    }else{
                        notFirst = true;
                    }
                    b.append(entry.getKey());
                    b.append('/');
                    b.append(entry.getValue().expression);
                }
                b.append(']');
                return b.toString();
            }

}
