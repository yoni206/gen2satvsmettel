/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package Lukavronb.language.Lukavronb;

import java.util.Map;
import java.util.TreeMap;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

import mettel.core.tableau.MettelSubstitution;
public class LukavronbTreeSubstitution implements LukavronbSubstitution{

    protected final Map<Lukavronb_valuationVariable, Lukavronb_valuation> valuationMap = new TreeMap<Lukavronb_valuationVariable, Lukavronb_valuation>();
    public Lukavronb_valuation get_valuation(Lukavronb_valuationVariable v){
        return valuationMap.get(v);
    }

    public Map<Lukavronb_valuationVariable, Lukavronb_valuation> valuationMap(){
        return valuationMap;
    }

    public boolean append(Lukavronb_valuationVariable v, Lukavronb_valuation e1){
        if(v == null || e1 == null){ return false; }
        final Lukavronb_valuation e = valuationMap.get(v);
        if(e == null){
            valuationMap.put(v,e1);
            return true;
        }else{
            return (e.equals(e1));
        }
    }

    protected final Map<Lukavronb_formulaVariable, Lukavronb_formula> formulaMap = new TreeMap<Lukavronb_formulaVariable, Lukavronb_formula>();
    public Lukavronb_formula get_formula(Lukavronb_formulaVariable v){
        return formulaMap.get(v);
    }

    public Map<Lukavronb_formulaVariable, Lukavronb_formula> formulaMap(){
        return formulaMap;
    }

    public boolean append(Lukavronb_formulaVariable v, Lukavronb_formula e1){
        if(v == null || e1 == null){ return false; }
        final Lukavronb_formula e = formulaMap.get(v);
        if(e == null){
            formulaMap.put(v,e1);
            return true;
        }else{
            return (e.equals(e1));
        }
    }

    public boolean append(LukavronbSubstitution s){
        final Map<Lukavronb_valuationVariable, Lukavronb_valuation> m_valuation = s.valuationMap();
        for(Lukavronb_valuationVariable key:m_valuation.keySet()){
            if(!append(key,s.get_valuation(key))){ return false; }
        }
        final Map<Lukavronb_formulaVariable, Lukavronb_formula> m_formula = s.formulaMap();
        for(Lukavronb_formulaVariable key:m_formula.keySet()){
            if(!append(key,s.get_formula(key))){ return false; }
        }
        return true;
    }

    public MettelSubstitution merge(MettelSubstitution s){
        LukavronbTreeSubstitution result = new LukavronbTreeSubstitution();
        result.append(this);
        if(result.append((LukavronbTreeSubstitution)s)){
            return result;
        }else{
            return null;
        }
    }

    private static LukavronbTreeSubstitution appendArray(LukavronbTreeSubstitution s, MettelSubstitution[] array){
        if(array == null) return null;
        final int SIZE = array.length;
        if(SIZE == 0) return null;
        for(int i = 0; i < SIZE; i++){
            Set<Entry<Lukavronb_valuationVariable, Lukavronb_valuation>> entry_valuationSet = ((LukavronbSubstitution)array[i]).valuationMap().entrySet();
            for(Entry<Lukavronb_valuationVariable, Lukavronb_valuation> entry:entry_valuationSet){
                if(!s.append(entry.getKey(),entry.getValue())) return null;
            }
            Set<Entry<Lukavronb_formulaVariable, Lukavronb_formula>> entry_formulaSet = ((LukavronbSubstitution)array[i]).formulaMap().entrySet();
            for(Entry<Lukavronb_formulaVariable, Lukavronb_formula> entry:entry_formulaSet){
                if(!s.append(entry.getKey(),entry.getValue())) return null;
            }
        }
        return s;
    }

    public MettelSubstitution mergeArray(MettelSubstitution[] array){
        return appendArray(new LukavronbTreeSubstitution(),array);
    }

    public MettelSubstitution merge(MettelSubstitution[] array){
        LukavronbTreeSubstitution s = new LukavronbTreeSubstitution();
        s.valuationMap().putAll(valuationMap);
        s.formulaMap().putAll(formulaMap);
        return appendArray(s,array);
    }

    public int compareTo(MettelSubstitution s){
        if(s == this){ return 0; }
        final Set<Lukavronb_valuationVariable> keys_valuation0 = valuationMap.keySet();
        final Set<Lukavronb_valuationVariable> keys_valuation1 = ((LukavronbSubstitution)s).valuationMap().keySet();
        final TreeSet<Lukavronb_valuationVariable> keys_valuation = new TreeSet<Lukavronb_valuationVariable>(keys_valuation0);
        keys_valuation.addAll(keys_valuation1);
        for(Lukavronb_valuationVariable key:keys_valuation){
            if(!keys_valuation0.contains(key)){
                return 1;
            }else{
                if(!keys_valuation1.contains(key)){
                    return -1;
                }else{
                    final Lukavronb_valuation v0 = valuationMap.get(key);
                    final Lukavronb_valuation v1 = ((LukavronbSubstitution)s).get_valuation(key);
                    final int result = v0.compareTo(v1);
                    if(result != 0){ return result; }
                }
            }
        }
        final Set<Lukavronb_formulaVariable> keys_formula0 = formulaMap.keySet();
        final Set<Lukavronb_formulaVariable> keys_formula1 = ((LukavronbSubstitution)s).formulaMap().keySet();
        final TreeSet<Lukavronb_formulaVariable> keys_formula = new TreeSet<Lukavronb_formulaVariable>(keys_formula0);
        keys_formula.addAll(keys_formula1);
        for(Lukavronb_formulaVariable key:keys_formula){
            if(!keys_formula0.contains(key)){
                return 1;
            }else{
                if(!keys_formula1.contains(key)){
                    return -1;
                }else{
                    final Lukavronb_formula v0 = formulaMap.get(key);
                    final Lukavronb_formula v1 = ((LukavronbSubstitution)s).get_formula(key);
                    final int result = v0.compareTo(v1);
                    if(result != 0){ return result; }
                }
            }
        }
        return 0;
    }

    private int hashCode = 0;
    public int hashCode(){
        hashCode = 1;
        hashCode = 31*hashCode + valuationMap.hashCode();
        hashCode = 31*hashCode + formulaMap.hashCode();
        return hashCode;
    }

    public boolean equals(Object o){
        if(o == this){ return true; }
        if(!(o instanceof LukavronbSubstitution)){ return false; }
        final LukavronbSubstitution s = (LukavronbSubstitution)o;
        return valuationMap.equals(s.valuationMap()) && formulaMap.equals(s.formulaMap());
    }

    public String toString(){
        StringBuilder b = new StringBuilder();
        b.append("$[");
        boolean notFirst = false;
        Set<Entry<Lukavronb_valuationVariable, Lukavronb_valuation>> valuationEntrySet = valuationMap.entrySet();
        for(Entry<Lukavronb_valuationVariable, Lukavronb_valuation> entry:valuationEntrySet){
            if(notFirst){
                b.append(", ");
            }else{
                notFirst = true;
            }
            b.append(entry.getKey());
            b.append('/');
            b.append(entry.getValue());
        }
        Set<Entry<Lukavronb_formulaVariable, Lukavronb_formula>> formulaEntrySet = formulaMap.entrySet();
        for(Entry<Lukavronb_formulaVariable, Lukavronb_formula> entry:formulaEntrySet){
            if(notFirst){
                b.append(", ");
            }else{
                notFirst = true;
            }
            b.append(entry.getKey());
            b.append('/');
            b.append(entry.getValue());
        }
        b.append(']');
        return b.toString();
    }

}
