/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package Lukavrona.language.Lukavrona;

import java.util.Map;
import java.util.TreeMap;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeSet;

import mettel.core.tableau.MettelSubstitution;
public class LukavronaTreeSubstitution implements LukavronaSubstitution{

    protected final Map<Lukavrona_valuationVariable, Lukavrona_valuation> valuationMap = new TreeMap<Lukavrona_valuationVariable, Lukavrona_valuation>();
    public Lukavrona_valuation get_valuation(Lukavrona_valuationVariable v){
        return valuationMap.get(v);
    }

    public Map<Lukavrona_valuationVariable, Lukavrona_valuation> valuationMap(){
        return valuationMap;
    }

    public boolean append(Lukavrona_valuationVariable v, Lukavrona_valuation e1){
        if(v == null || e1 == null){ return false; }
        final Lukavrona_valuation e = valuationMap.get(v);
        if(e == null){
            valuationMap.put(v,e1);
            return true;
        }else{
            return (e.equals(e1));
        }
    }

    protected final Map<Lukavrona_formulaVariable, Lukavrona_formula> formulaMap = new TreeMap<Lukavrona_formulaVariable, Lukavrona_formula>();
    public Lukavrona_formula get_formula(Lukavrona_formulaVariable v){
        return formulaMap.get(v);
    }

    public Map<Lukavrona_formulaVariable, Lukavrona_formula> formulaMap(){
        return formulaMap;
    }

    public boolean append(Lukavrona_formulaVariable v, Lukavrona_formula e1){
        if(v == null || e1 == null){ return false; }
        final Lukavrona_formula e = formulaMap.get(v);
        if(e == null){
            formulaMap.put(v,e1);
            return true;
        }else{
            return (e.equals(e1));
        }
    }

    public boolean append(LukavronaSubstitution s){
        final Map<Lukavrona_valuationVariable, Lukavrona_valuation> m_valuation = s.valuationMap();
        for(Lukavrona_valuationVariable key:m_valuation.keySet()){
            if(!append(key,s.get_valuation(key))){ return false; }
        }
        final Map<Lukavrona_formulaVariable, Lukavrona_formula> m_formula = s.formulaMap();
        for(Lukavrona_formulaVariable key:m_formula.keySet()){
            if(!append(key,s.get_formula(key))){ return false; }
        }
        return true;
    }

    public MettelSubstitution merge(MettelSubstitution s){
        LukavronaTreeSubstitution result = new LukavronaTreeSubstitution();
        result.append(this);
        if(result.append((LukavronaTreeSubstitution)s)){
            return result;
        }else{
            return null;
        }
    }

    private static LukavronaTreeSubstitution appendArray(LukavronaTreeSubstitution s, MettelSubstitution[] array){
        if(array == null) return null;
        final int SIZE = array.length;
        if(SIZE == 0) return null;
        for(int i = 0; i < SIZE; i++){
            Set<Entry<Lukavrona_valuationVariable, Lukavrona_valuation>> entry_valuationSet = ((LukavronaSubstitution)array[i]).valuationMap().entrySet();
            for(Entry<Lukavrona_valuationVariable, Lukavrona_valuation> entry:entry_valuationSet){
                if(!s.append(entry.getKey(),entry.getValue())) return null;
            }
            Set<Entry<Lukavrona_formulaVariable, Lukavrona_formula>> entry_formulaSet = ((LukavronaSubstitution)array[i]).formulaMap().entrySet();
            for(Entry<Lukavrona_formulaVariable, Lukavrona_formula> entry:entry_formulaSet){
                if(!s.append(entry.getKey(),entry.getValue())) return null;
            }
        }
        return s;
    }

    public MettelSubstitution mergeArray(MettelSubstitution[] array){
        return appendArray(new LukavronaTreeSubstitution(),array);
    }

    public MettelSubstitution merge(MettelSubstitution[] array){
        LukavronaTreeSubstitution s = new LukavronaTreeSubstitution();
        s.valuationMap().putAll(valuationMap);
        s.formulaMap().putAll(formulaMap);
        return appendArray(s,array);
    }

    public int compareTo(MettelSubstitution s){
        if(s == this){ return 0; }
        final Set<Lukavrona_valuationVariable> keys_valuation0 = valuationMap.keySet();
        final Set<Lukavrona_valuationVariable> keys_valuation1 = ((LukavronaSubstitution)s).valuationMap().keySet();
        final TreeSet<Lukavrona_valuationVariable> keys_valuation = new TreeSet<Lukavrona_valuationVariable>(keys_valuation0);
        keys_valuation.addAll(keys_valuation1);
        for(Lukavrona_valuationVariable key:keys_valuation){
            if(!keys_valuation0.contains(key)){
                return 1;
            }else{
                if(!keys_valuation1.contains(key)){
                    return -1;
                }else{
                    final Lukavrona_valuation v0 = valuationMap.get(key);
                    final Lukavrona_valuation v1 = ((LukavronaSubstitution)s).get_valuation(key);
                    final int result = v0.compareTo(v1);
                    if(result != 0){ return result; }
                }
            }
        }
        final Set<Lukavrona_formulaVariable> keys_formula0 = formulaMap.keySet();
        final Set<Lukavrona_formulaVariable> keys_formula1 = ((LukavronaSubstitution)s).formulaMap().keySet();
        final TreeSet<Lukavrona_formulaVariable> keys_formula = new TreeSet<Lukavrona_formulaVariable>(keys_formula0);
        keys_formula.addAll(keys_formula1);
        for(Lukavrona_formulaVariable key:keys_formula){
            if(!keys_formula0.contains(key)){
                return 1;
            }else{
                if(!keys_formula1.contains(key)){
                    return -1;
                }else{
                    final Lukavrona_formula v0 = formulaMap.get(key);
                    final Lukavrona_formula v1 = ((LukavronaSubstitution)s).get_formula(key);
                    final int result = v0.compareTo(v1);
                    if(result != 0){ return result; }
                }
            }
        }
        return 0;
    }

    private int hashCode = 0;
    public int hashCode(){
        hashCode = 1;
        hashCode = 31*hashCode + valuationMap.hashCode();
        hashCode = 31*hashCode + formulaMap.hashCode();
        return hashCode;
    }

    public boolean equals(Object o){
        if(o == this){ return true; }
        if(!(o instanceof LukavronaSubstitution)){ return false; }
        final LukavronaSubstitution s = (LukavronaSubstitution)o;
        return valuationMap.equals(s.valuationMap()) && formulaMap.equals(s.formulaMap());
    }

    public String toString(){
        StringBuilder b = new StringBuilder();
        b.append("$[");
        boolean notFirst = false;
        Set<Entry<Lukavrona_valuationVariable, Lukavrona_valuation>> valuationEntrySet = valuationMap.entrySet();
        for(Entry<Lukavrona_valuationVariable, Lukavrona_valuation> entry:valuationEntrySet){
            if(notFirst){
                b.append(", ");
            }else{
                notFirst = true;
            }
            b.append(entry.getKey());
            b.append('/');
            b.append(entry.getValue());
        }
        Set<Entry<Lukavrona_formulaVariable, Lukavrona_formula>> formulaEntrySet = formulaMap.entrySet();
        for(Entry<Lukavrona_formulaVariable, Lukavrona_formula> entry:formulaEntrySet){
            if(notFirst){
                b.append(", ");
            }else{
                notFirst = true;
            }
            b.append(entry.getKey());
            b.append('/');
            b.append(entry.getValue());
        }
        b.append(']');
        return b.toString();
    }

}
