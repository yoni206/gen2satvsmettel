/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package Lukavrona.language.Lukavrona;

import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.TreeSet;
import java.util.Map.Entry;
import mettel.core.tableau.MettelReplacement;
import mettel.core.tableau.MettelSubstitution;
import mettel.core.tableau.MettelExpression;

public class LukavronaTreeReplacement implements LukavronaReplacement{

    private class Pointer<T extends LukavronaExpression>{
        T expression = null;
        Pointer(T expression){
            super();
            this.expression = expression;
        }
        public int hashCode(){
            return expression.hashCode();
        }
    }

    private Comparator<LukavronaAbstractExpression> comparator = new LukavronaIDComparator();

    protected final Map<Lukavrona_valuation, Pointer<Lukavrona_valuation>> valuationMap = new TreeMap<Lukavrona_valuation, Pointer<Lukavrona_valuation>>();
    public Lukavrona_valuation get_valuation(Lukavrona_valuation e){
        final Pointer<Lukavrona_valuation> p = valuationMap.get(e);
        return p == null? null: p.expression;
    }

    public Set<Lukavrona_valuation> valuationKeys(){
        return valuationMap.keySet();
    }

    public boolean append(Lukavrona_valuation e0, Lukavrona_valuation e1){
        if(e0 == null || e1 == null){ return false; }
        final int CMP = comparator.compare((LukavronaAbstractExpression)e0,(LukavronaAbstractExpression)e1);
        if(CMP == 0) return false;
            Lukavrona_valuation left = null;
            Lukavrona_valuation right = null;
            if(CMP > 0){
                left = e0;
                right = e1;
            }else{
                left = e1;
                right = e0;
            }
            final Pointer<Lukavrona_valuation> entry = valuationMap.get(left);
            if(entry == null){
                final Pointer<Lukavrona_valuation> rEntry = valuationMap.get(right);
                if(rEntry == null) {
                    valuationMap.put(left, new Pointer<Lukavrona_valuation>(right));
                }else{
                    valuationMap.put(left, rEntry);
                }
                return true;
            }else{
                final Lukavrona_valuation third = entry.expression;
                final int CMP0 = comparator.compare((LukavronaAbstractExpression)right, (LukavronaAbstractExpression)third);
                if(CMP0 == 0) return false;
                if(CMP0 > 0){
                    valuationMap.put(right, entry);
                    return true;
                }else{
                    entry.expression = right;
                    valuationMap.put(third, entry);
                    return true;
                }
            }
        }

        protected final Map<Lukavrona_formula, Pointer<Lukavrona_formula>> formulaMap = new TreeMap<Lukavrona_formula, Pointer<Lukavrona_formula>>();
        public Lukavrona_formula get_formula(Lukavrona_formula e){
            final Pointer<Lukavrona_formula> p = formulaMap.get(e);
            return p == null? null: p.expression;
        }

        public Set<Lukavrona_formula> formulaKeys(){
            return formulaMap.keySet();
        }

        public boolean append(Lukavrona_formula e0, Lukavrona_formula e1){
            if(e0 == null || e1 == null){ return false; }
            final int CMP = comparator.compare((LukavronaAbstractExpression)e0,(LukavronaAbstractExpression)e1);
            if(CMP == 0) return false;
                Lukavrona_formula left = null;
                Lukavrona_formula right = null;
                if(CMP > 0){
                    left = e0;
                    right = e1;
                }else{
                    left = e1;
                    right = e0;
                }
                final Pointer<Lukavrona_formula> entry = formulaMap.get(left);
                if(entry == null){
                    final Pointer<Lukavrona_formula> rEntry = formulaMap.get(right);
                    if(rEntry == null) {
                        formulaMap.put(left, new Pointer<Lukavrona_formula>(right));
                    }else{
                        formulaMap.put(left, rEntry);
                    }
                    return true;
                }else{
                    final Lukavrona_formula third = entry.expression;
                    final int CMP0 = comparator.compare((LukavronaAbstractExpression)right, (LukavronaAbstractExpression)third);
                    if(CMP0 == 0) return false;
                    if(CMP0 > 0){
                        formulaMap.put(right, entry);
                        return true;
                    }else{
                        entry.expression = right;
                        formulaMap.put(third, entry);
                        return true;
                    }
                }
            }

            public boolean isEmpty(){
                return valuationMap.isEmpty() && formulaMap.isEmpty();
            }

            public boolean append(MettelExpression e0, MettelExpression e1){
                if(e0 instanceof Lukavrona_valuation){ return append((Lukavrona_valuation)e0, (Lukavrona_valuation)e1); }
                if(e0 instanceof Lukavrona_formula){ return append((Lukavrona_formula)e0, (Lukavrona_formula)e1); }
                return false;
            }

            public boolean append(MettelReplacement r){
                if(r == null){ return false; }
                return append((LukavronaReplacement)r);
            }

            public MettelExpression rewrite(MettelExpression e) {
                if(e instanceof Lukavrona_valuation){
                    return ((Lukavrona_valuation)e).rewrite(this);
                }
                if(e instanceof Lukavrona_formula){
                    return ((Lukavrona_formula)e).rewrite(this);
                }
                return null;
            }

            public MettelSubstitution rewrite(MettelSubstitution s) {
                final LukavronaSubstitution s0 = (LukavronaSubstitution)s;
                LukavronaSubstitution res = new LukavronaTreeSubstitution();
                final Set<Entry<Lukavrona_valuationVariable, Lukavrona_valuation>> valuationEntrySet = s0.valuationMap().entrySet();
                for(Entry<Lukavrona_valuationVariable, Lukavrona_valuation> entry:valuationEntrySet){
                    res.append(entry.getKey(),(Lukavrona_valuation)rewrite(entry.getValue()));
                }
                final Set<Entry<Lukavrona_formulaVariable, Lukavrona_formula>> formulaEntrySet = s0.formulaMap().entrySet();
                for(Entry<Lukavrona_formulaVariable, Lukavrona_formula> entry:formulaEntrySet){
                    res.append(entry.getKey(),(Lukavrona_formula)rewrite(entry.getValue()));
                }
                return res;
            }

            public boolean append(LukavronaReplacement r){
                boolean result = false;
                final Set<Lukavrona_valuation> valuationKeys = r.valuationKeys();
                for(Lukavrona_valuation key:valuationKeys){
                    result |= append(key, r.get_valuation(key));
                }
                final Set<Lukavrona_formula> formulaKeys = r.formulaKeys();
                for(Lukavrona_formula key:formulaKeys){
                    result |= append(key, r.get_formula(key));
                }
                return result;
            }

            private int hashCode = 0;
            public int hashCode(){
                hashCode = 1;
                hashCode = 31*hashCode + valuationMap.hashCode();
                hashCode = 31*hashCode + formulaMap.hashCode();
                return hashCode;
            }

            public int compareTo(MettelReplacement r){
                if(r == this){ return 0; }
                final Set<Lukavrona_valuation> keys_valuation0 = valuationMap.keySet();
                final Set<Lukavrona_valuation> keys_valuation1 = ((LukavronaReplacement)r).valuationKeys();
                final TreeSet<Lukavrona_valuation> keys_valuation = new TreeSet<Lukavrona_valuation>(keys_valuation0);
                keys_valuation.addAll(keys_valuation1);
                for(Lukavrona_valuation key:keys_valuation){
                    if(!keys_valuation0.contains(key)){
                        return 1;
                    }else{
                        if(!keys_valuation1.contains(key)){
                            return -1;
                        }else{
                            final Lukavrona_valuation v0 = valuationMap.get(key).expression;
                            final Lukavrona_valuation v1 = ((LukavronaReplacement)r).get_valuation(key);
                            final int result = v0.compareTo(v1);
                            if(result != 0){ return result; }
                        }
                    }
                }
                final Set<Lukavrona_formula> keys_formula0 = formulaMap.keySet();
                final Set<Lukavrona_formula> keys_formula1 = ((LukavronaReplacement)r).formulaKeys();
                final TreeSet<Lukavrona_formula> keys_formula = new TreeSet<Lukavrona_formula>(keys_formula0);
                keys_formula.addAll(keys_formula1);
                for(Lukavrona_formula key:keys_formula){
                    if(!keys_formula0.contains(key)){
                        return 1;
                    }else{
                        if(!keys_formula1.contains(key)){
                            return -1;
                        }else{
                            final Lukavrona_formula v0 = formulaMap.get(key).expression;
                            final Lukavrona_formula v1 = ((LukavronaReplacement)r).get_formula(key);
                            final int result = v0.compareTo(v1);
                            if(result != 0){ return result; }
                        }
                    }
                }
                return 0;
            }

            public boolean equals(Object o){
                if(o == this){ return true; }
                if(!(o instanceof LukavronaReplacement)){ return false; }
                final LukavronaReplacement r = (LukavronaReplacement)o;
                final Set<Lukavrona_valuation> valuationKeys = valuationMap.keySet();
                if(!valuationKeys.equals(r.valuationKeys())) return false;
                for(Lukavrona_valuation key:valuationKeys){
                    final Lukavrona_valuation v = valuationMap.get(key).expression;
                    if(!v.equals(r.get_valuation(key))) return false;
                }
                final Set<Lukavrona_formula> formulaKeys = formulaMap.keySet();
                if(!formulaKeys.equals(r.formulaKeys())) return false;
                for(Lukavrona_formula key:formulaKeys){
                    final Lukavrona_formula v = formulaMap.get(key).expression;
                    if(!v.equals(r.get_formula(key))) return false;
                }
                return true;
            }

            public String toString(){
                StringBuilder b = new StringBuilder();
                b.append("$[");
                boolean notFirst = false;
                final Set<Entry<Lukavrona_valuation, Pointer<Lukavrona_valuation>>> valuationEntrySet = valuationMap.entrySet();
                for(Entry<Lukavrona_valuation, Pointer<Lukavrona_valuation>> entry:valuationEntrySet){
                    if(notFirst){
                        b.append(", ");
                    }else{
                        notFirst = true;
                    }
                    b.append(entry.getKey());
                    b.append('/');
                    b.append(entry.getValue().expression);
                }
                final Set<Entry<Lukavrona_formula, Pointer<Lukavrona_formula>>> formulaEntrySet = formulaMap.entrySet();
                for(Entry<Lukavrona_formula, Pointer<Lukavrona_formula>> entry:formulaEntrySet){
                    if(notFirst){
                        b.append(", ");
                    }else{
                        notFirst = true;
                    }
                    b.append(entry.getKey());
                    b.append('/');
                    b.append(entry.getValue().expression);
                }
                b.append(']');
                return b.toString();
            }

}
