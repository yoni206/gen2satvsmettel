/**
 * This file is generated by MetTeL v2
 * which is designed and implemented
 * by Dmitry Tishkovsky.
 */
package Lukavrona.language.Lukavrona.util;

import Lukavrona.language.Lukavrona.Lukavrona_valuation;
import Lukavrona.language.Lukavrona.Lukavrona_valuationVariable;
import Lukavrona.language.Lukavrona.Lukavrona_formula;
import Lukavrona.language.Lukavrona.Lukavrona_formulaVariable;

import Lukavrona.language.Lukavrona.LukavronaObjectFactory;
import Lukavrona.language.Lukavrona.LukavronaProblemAnalyzer;
import mettel.util.MettelProblemFile;

import mettel.core.MettelCoreRuntimeException;

import java.util.Collection;
import java.util.Random;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.util.Properties;
import java.util.StringTokenizer;

import org.antlr.runtime.RecognitionException;
public class LukavronaRandomExpressionGenerator implements LukavronaExpressionGenerator{

    private static FileReader prop = null;
    private static boolean standardOutput = false;
    private static String outputPath = "random_problems";
    private static int fileIndex = 0;
    private static Properties configuration = new Properties();
    private static LukavronaRandomExpressionGenerator g = new LukavronaRandomExpressionGenerator();

    public static void main(String[] args) {
        System.out.println("-------------------------------------------------------------------");
        System.out.println("Hello there! I am a random expression generator for Lukavrona logic.");
        System.out.println("I am generated by MetTeL, an automated tableau prover generator,");
        System.out.println("which is designed and implemented by Dmitry Tishkovsky.");
        System.out.println("As a program, I have ABSOLUTELY NO WARRANTY.");
        System.out.println("-------------------------------------------------------------------");
        try{
            parseCommandLineArguments(args);

            if (prop != null){
                setProperties();
                checkPropertiesValidity();
            }else{
                setDefaultProperties();
            }

            outputGeneratedExpressions();

        } catch(Exception e) {
            System.out.println("Sorry! I detected an exceptional situation and terminate now.");
            System.out.println("If you can help me to avoid this situation in future, please look at my error output.");
            System.err.println("==Exception==========================");
            e.printStackTrace(System.err);
            System.err.println("=====================================");
            System.exit(-1);
        }
    }

    private static void parseCommandLineArguments(String[] args) throws IOException{
        final int SIZE = args.length;
        for(int i = 0; i < SIZE; i++){
            if("-".equals(args[i])){
                standardOutput = true;
            }else if("-d".equals(args[i])||"--output-directory".equals(args[i])){
                if(i < SIZE-1){
                    outputPath = args[++i];
                    System.out.println("Output path: " + outputPath);
                }else{
                    System.out.println("I need a name of directory where I will put generated random expressions.");
                    System.exit(-1);
                }
            }else if("-p".equals(args[i])||"--properties".equals(args[i])){
                if(i < SIZE-1){
                    prop = new FileReader(args[++i]);
                    System.out.println("Properties file: " + args[i]);
                }else{
                    System.out.println("I need a name of file where you have specified properties of the random expression generator.");
                    System.exit(-1);
                }
            }else if("--file-index".equals(args[i])){
                if(i < SIZE-1){
                    fileIndex = Integer.parseInt(args[++i]);
                    System.out.println("Starting file index is: " + fileIndex);
                }else{
                    System.out.println("I need a number which specified starting index of file names");
                    System.exit(-1);
                }
            }
        }
    }

    private static void setProperties() throws IOException{
        String variablesNamesLine;
        StringTokenizer variablesNamesTokenizer;
        String[] variablesNames;

        configuration.load(prop);
        g.set_true_valuationFrequency(Integer.parseInt(configuration.getProperty("valuation.true.frequency", "1").trim()));
        g.set_false_valuationFrequency(Integer.parseInt(configuration.getProperty("valuation.false.frequency", "1").trim()));

        g.set_valuationVariableFrequency(Integer.parseInt(configuration.getProperty("valuation.variable.frequency", "1").trim()));
        g.setDepth_valuation(Integer.parseInt(configuration.getProperty("valuation.depth", "3").trim()));

        variablesNamesLine = configuration.getProperty("valuation.variables", "null");
        variablesNamesTokenizer = new StringTokenizer(variablesNamesLine, ",");
        if (variablesNamesTokenizer.countTokens() == 0){
            variablesNames = null;
        }else{
            variablesNames = new String[variablesNamesTokenizer.countTokens()];
            for (int i = 0; i < variablesNames.length; i++)
                variablesNames[i] = variablesNamesTokenizer.nextToken().trim();
        }
        g.set_valuationVariables(variablesNames);

        g.set_valuationVariablesSize(Integer.parseInt(configuration.getProperty("valuation.variables.number", "3").trim()));

        g.set_valuationTimesToRun(Integer.parseInt(configuration.getProperty("valuation.generate", "5").trim()));

        variablesNamesLine = configuration.getProperty("valuation.top.connectives", "null");
        variablesNamesTokenizer = new StringTokenizer(variablesNamesLine, ",");
        if (variablesNamesTokenizer.countTokens() == 0){
            variablesNames = null;
        }else{
            variablesNames = new String[variablesNamesTokenizer.countTokens()];
            for (int i = 0; i < variablesNames.length; i++)
                variablesNames[i] = variablesNamesTokenizer.nextToken().trim();
        }
        g.set_valuationTopConnectives(variablesNames);

        g.set_negation_formulaFrequency(Integer.parseInt(configuration.getProperty("formula.negation.frequency", "1").trim()));
        g.set_conjunction_formulaFrequency(Integer.parseInt(configuration.getProperty("formula.conjunction.frequency", "1").trim()));
        g.set_disjunction_formulaFrequency(Integer.parseInt(configuration.getProperty("formula.disjunction.frequency", "1").trim()));
        g.set_implication_formulaFrequency(Integer.parseInt(configuration.getProperty("formula.implication.frequency", "1").trim()));

        g.set_formulaVariableFrequency(Integer.parseInt(configuration.getProperty("formula.variable.frequency", "1").trim()));
        g.setDepth_formula(Integer.parseInt(configuration.getProperty("formula.depth", "3").trim()));

        variablesNamesLine = configuration.getProperty("formula.variables", "null");
        variablesNamesTokenizer = new StringTokenizer(variablesNamesLine, ",");
        if (variablesNamesTokenizer.countTokens() == 0){
            variablesNames = null;
        }else{
            variablesNames = new String[variablesNamesTokenizer.countTokens()];
            for (int i = 0; i < variablesNames.length; i++)
                variablesNames[i] = variablesNamesTokenizer.nextToken().trim();
        }
        g.set_formulaVariables(variablesNames);

        g.set_formulaVariablesSize(Integer.parseInt(configuration.getProperty("formula.variables.number", "3").trim()));

        g.set_formulaTimesToRun(Integer.parseInt(configuration.getProperty("formula.generate", "5").trim()));

        variablesNamesLine = configuration.getProperty("formula.top.connectives", "null");
        variablesNamesTokenizer = new StringTokenizer(variablesNamesLine, ",");
        if (variablesNamesTokenizer.countTokens() == 0){
            variablesNames = null;
        }else{
            variablesNames = new String[variablesNamesTokenizer.countTokens()];
            for (int i = 0; i < variablesNames.length; i++)
                variablesNames[i] = variablesNamesTokenizer.nextToken().trim();
        }
        g.set_formulaTopConnectives(variablesNames);

    }

    private static void checkPropertiesValidity() {
        if(g.valuationVariableFrequency == 0)
            throw new MettelCoreRuntimeException("You can't have 0 frequencies in all variables and constants in valuation sort.");
        if(g.formulaVariableFrequency == 0)
            throw new MettelCoreRuntimeException("You can't have 0 frequencies in all variables and constants in formula sort.");
    }

    private static void outputGeneratedExpressions() throws IOException, RecognitionException{
        new File(outputPath).mkdir();
        File outputFile;
        String generatedExpression;
        for (int i = 0; i < g.valuationTimesToRun; i++){
            while ((outputFile = new File(outputPath + "/Lukavrona_" + fileIndex + ".mtl")).exists()){
                fileIndex++;
            }
            MettelProblemFile problemFile = new MettelProblemFile(outputFile);
            generatedExpression = g.valuation().toString();
            ByteArrayInputStream expressionStream = new ByteArrayInputStream(generatedExpression.getBytes());
            LukavronaProblemAnalyzer expressionAnalyzer = new LukavronaProblemAnalyzer(expressionStream);
            problemFile.setGeneratorProperties(configuration);
            problemFile.setStatisticsProperties(expressionAnalyzer.getStatistics());
            problemFile.setExpressions(generatedExpression);
            problemFile.writeToFile();
        }
        for (int i = 0; i < g.formulaTimesToRun; i++){
            while ((outputFile = new File(outputPath + "/Lukavrona_" + fileIndex + ".mtl")).exists()){
                fileIndex++;
            }
            MettelProblemFile problemFile = new MettelProblemFile(outputFile);
            generatedExpression = g.formula().toString();
            ByteArrayInputStream expressionStream = new ByteArrayInputStream(generatedExpression.getBytes());
            LukavronaProblemAnalyzer expressionAnalyzer = new LukavronaProblemAnalyzer(expressionStream);
            problemFile.setGeneratorProperties(configuration);
            problemFile.setStatisticsProperties(expressionAnalyzer.getStatistics());
            problemFile.setExpressions(generatedExpression);
            problemFile.writeToFile();
        }
    }

    private static void setDefaultProperties(){
        configuration.setProperty("MetTeL.version", "TODO");
        configuration.setProperty("syntax.file", "TODO");
        configuration.setProperty("valuation.true.frequency", "1");
        configuration.setProperty("valuation.false.frequency", "1");
        configuration.setProperty("valuation.variable.frequency", "1");
        configuration.setProperty("valuation.depth", "3");
        configuration.setProperty("valuation.variables", "");
        configuration.setProperty("valuation.variables.number", "3");
        configuration.setProperty("valuation.generate", "5");
        configuration.setProperty("valuation.top.connectives", "");
        configuration.setProperty("formula.negation.frequency", "1");
        configuration.setProperty("formula.conjunction.frequency", "1");
        configuration.setProperty("formula.disjunction.frequency", "1");
        configuration.setProperty("formula.implication.frequency", "1");
        configuration.setProperty("formula.variable.frequency", "1");
        configuration.setProperty("formula.depth", "3");
        configuration.setProperty("formula.variables", "");
        configuration.setProperty("formula.variables.number", "3");
        configuration.setProperty("formula.generate", "5");
        configuration.setProperty("formula.top.connectives", "");
    }

    private LukavronaObjectFactory factory = LukavronaObjectFactory.DEFAULT;

    public LukavronaRandomExpressionGenerator() {
        super();
    }

    public LukavronaRandomExpressionGenerator(LukavronaObjectFactory factory) {
        super();
        this.factory = factory;
    }

    private Random random = new Random();

    private int true_valuationFrequency = 1;

    public void set_true_valuationFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_valuationFrequency += (f - true_valuationFrequency);
        true_valuationFrequency = f;
    }

    private int false_valuationFrequency = 1;

    public void set_false_valuationFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_valuationFrequency += (f - false_valuationFrequency);
        false_valuationFrequency = f;
    }

    private int valuationVariableFrequency = 1;
    public void set_valuationVariableFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_valuationFrequency += (f - valuationVariableFrequency);
        total_valuationConstantsVariablesFrequency += (f - valuationVariableFrequency);
        valuationVariableFrequency = f;
    }

    private int total_valuationFrequency = 3;
    private int total_valuationConstantsVariablesFrequency = 1;

    private int depth_valuation = 3;

    public void setDepth_valuation(int d){
        depth_valuation = d;
    }

    public Lukavrona_valuation valuation(){
        if (valuationTopConnectives != null){
            int totalTopConnectivesFrequency = 0;
            for (String connective : valuationTopConnectives){
                if ("true".equals(connective)){
                    totalTopConnectivesFrequency += true_valuationFrequency;
                }
                if ("false".equals(connective)){
                    totalTopConnectivesFrequency += false_valuationFrequency;
                }
            }
            int r = random.nextInt(totalTopConnectivesFrequency);
            for (String connective : valuationTopConnectives){
                if ("true".equals(connective) && r < true_valuationFrequency){
                    return factory.create_true_valuation(formula(depth_valuation-1));
                }else{
                    if ("true".equals(connective))
                        r -= true_valuationFrequency;
                    if ("false".equals(connective) && r < false_valuationFrequency){
                        return factory.create_false_valuation(formula(depth_valuation-1));
                    }else{
                        if ("false".equals(connective))
                            r -= false_valuationFrequency;
                    }
                }
            }
        }else{
            return valuation(depth_valuation);
        }
        throw new MettelCoreRuntimeException("Something wrong with top.connectives");
    }

    private Lukavrona_valuation valuation(int d){
        if(depth_valuation > 0 && d <= 0){
            int r = random.nextInt(total_valuationConstantsVariablesFrequency);
            return valuationVariable();
        }

        int r = random.nextInt(total_valuationFrequency);

        if(r < true_valuationFrequency){
            return factory.create_true_valuation(formula(d-1));
        }else{
            r -= true_valuationFrequency;
            if(r < false_valuationFrequency){
                return factory.create_false_valuation(formula(d-1));
            }else{
                r -= false_valuationFrequency;
                return valuationVariable();
            }
        }
    }

    private String[] valuationVariables = null;
    private int valuationVariablesSize = 3;

    public void set_valuationVariables(String[] names){
        if(names == null) return;
        valuationVariablesSize = names.length;
        valuationVariables = new String[valuationVariablesSize];
        System.arraycopy(names, 0, valuationVariables, 0, valuationVariablesSize);
    }

    public void set_valuationVariables(Collection<Lukavrona_valuationVariable> vars){
        if(vars == null) return;
        valuationVariablesSize = vars.size();
        valuationVariables = new String[valuationVariablesSize];
        Lukavrona_valuationVariable[] vv = (Lukavrona_valuationVariable[]) vars.toArray();
        for(int i = 0; i < valuationVariablesSize; i++){
            valuationVariables[i] = vv[i].name();
        }
    }

    public void set_valuationVariablesSize(int size){
        valuationVariablesSize = size;
    }

    protected final Lukavrona_valuationVariable valuationVariable(){
        int r = random.nextInt(valuationVariablesSize);
        return factory.create_valuationVariable((valuationVariables != null && r < valuationVariables.length)? valuationVariables[r]: "$valuationVariable"+r );
    }

    private int valuationTimesToRun = 5;

    public void set_valuationTimesToRun(int times){
        valuationTimesToRun = times;
    }

    private String[] valuationTopConnectives = null;

    public void set_valuationTopConnectives(String[] topConnectives){
        valuationTopConnectives = topConnectives;
    }
    private int negation_formulaFrequency = 1;

    public void set_negation_formulaFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_formulaFrequency += (f - negation_formulaFrequency);
        negation_formulaFrequency = f;
    }

    private int conjunction_formulaFrequency = 1;

    public void set_conjunction_formulaFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_formulaFrequency += (f - conjunction_formulaFrequency);
        conjunction_formulaFrequency = f;
    }

    private int disjunction_formulaFrequency = 1;

    public void set_disjunction_formulaFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_formulaFrequency += (f - disjunction_formulaFrequency);
        disjunction_formulaFrequency = f;
    }

    private int implication_formulaFrequency = 1;

    public void set_implication_formulaFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_formulaFrequency += (f - implication_formulaFrequency);
        implication_formulaFrequency = f;
    }

    private int formulaVariableFrequency = 1;
    public void set_formulaVariableFrequency(int f){
        if(f < 0) throw new MettelCoreRuntimeException("Frequency parameter is negative");
        total_formulaFrequency += (f - formulaVariableFrequency);
        total_formulaConstantsVariablesFrequency += (f - formulaVariableFrequency);
        formulaVariableFrequency = f;
    }

    private int total_formulaFrequency = 5;
    private int total_formulaConstantsVariablesFrequency = 1;

    private int depth_formula = 3;

    public void setDepth_formula(int d){
        depth_formula = d;
    }

    public Lukavrona_formula formula(){
        if (formulaTopConnectives != null){
            int totalTopConnectivesFrequency = 0;
            for (String connective : formulaTopConnectives){
                if ("negation".equals(connective)){
                    totalTopConnectivesFrequency += negation_formulaFrequency;
                }
                if ("conjunction".equals(connective)){
                    totalTopConnectivesFrequency += conjunction_formulaFrequency;
                }
                if ("disjunction".equals(connective)){
                    totalTopConnectivesFrequency += disjunction_formulaFrequency;
                }
                if ("implication".equals(connective)){
                    totalTopConnectivesFrequency += implication_formulaFrequency;
                }
            }
            int r = random.nextInt(totalTopConnectivesFrequency);
            for (String connective : formulaTopConnectives){
                if ("negation".equals(connective) && r < negation_formulaFrequency){
                    return factory.create_negation_formula(formula(depth_formula-1));
                }else{
                    if ("negation".equals(connective))
                        r -= negation_formulaFrequency;
                    if ("conjunction".equals(connective) && r < conjunction_formulaFrequency){
                        return factory.create_conjunction_formula(formula(depth_formula-1), formula(depth_formula-1));
                    }else{
                        if ("conjunction".equals(connective))
                            r -= conjunction_formulaFrequency;
                        if ("disjunction".equals(connective) && r < disjunction_formulaFrequency){
                            return factory.create_disjunction_formula(formula(depth_formula-1), formula(depth_formula-1));
                        }else{
                            if ("disjunction".equals(connective))
                                r -= disjunction_formulaFrequency;
                            if ("implication".equals(connective) && r < implication_formulaFrequency){
                                return factory.create_implication_formula(formula(depth_formula-1), formula(depth_formula-1));
                            }else{
                                if ("implication".equals(connective))
                                    r -= implication_formulaFrequency;
                            }
                        }
                    }
                }
            }
        }else{
            return formula(depth_formula);
        }
        throw new MettelCoreRuntimeException("Something wrong with top.connectives");
    }

    private Lukavrona_formula formula(int d){
        if(depth_formula > 0 && d <= 0){
            int r = random.nextInt(total_formulaConstantsVariablesFrequency);
            return formulaVariable();
        }

        int r = random.nextInt(total_formulaFrequency);

        if(r < negation_formulaFrequency){
            return factory.create_negation_formula(formula(d-1));
        }else{
            r -= negation_formulaFrequency;
            if(r < conjunction_formulaFrequency){
                return factory.create_conjunction_formula(formula(d-1), formula(d-1));
            }else{
                r -= conjunction_formulaFrequency;
                if(r < disjunction_formulaFrequency){
                    return factory.create_disjunction_formula(formula(d-1), formula(d-1));
                }else{
                    r -= disjunction_formulaFrequency;
                    if(r < implication_formulaFrequency){
                        return factory.create_implication_formula(formula(d-1), formula(d-1));
                    }else{
                        r -= implication_formulaFrequency;
                        return formulaVariable();
                    }
                }
            }
        }
    }

    private String[] formulaVariables = null;
    private int formulaVariablesSize = 3;

    public void set_formulaVariables(String[] names){
        if(names == null) return;
        formulaVariablesSize = names.length;
        formulaVariables = new String[formulaVariablesSize];
        System.arraycopy(names, 0, formulaVariables, 0, formulaVariablesSize);
    }

    public void set_formulaVariables(Collection<Lukavrona_formulaVariable> vars){
        if(vars == null) return;
        formulaVariablesSize = vars.size();
        formulaVariables = new String[formulaVariablesSize];
        Lukavrona_formulaVariable[] vv = (Lukavrona_formulaVariable[]) vars.toArray();
        for(int i = 0; i < formulaVariablesSize; i++){
            formulaVariables[i] = vv[i].name();
        }
    }

    public void set_formulaVariablesSize(int size){
        formulaVariablesSize = size;
    }

    protected final Lukavrona_formulaVariable formulaVariable(){
        int r = random.nextInt(formulaVariablesSize);
        return factory.create_formulaVariable((formulaVariables != null && r < formulaVariables.length)? formulaVariables[r]: "$formulaVariable"+r );
    }

    private int formulaTimesToRun = 5;

    public void set_formulaTimesToRun(int times){
        formulaTimesToRun = times;
    }

    private String[] formulaTopConnectives = null;

    public void set_formulaTopConnectives(String[] topConnectives){
        formulaTopConnectives = topConnectives;
    }
}
